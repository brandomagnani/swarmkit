{
  "title": "New ELF Linker from the LLVM Project",
  "summary": "In November 2015, the LLVM project announced that their new ELF linker (lld) had reached a major milestone: it could bootstrap LLVM, Clang, and itself while passing all tests on x86-64 Linux and FreeBSD. The key achievement was performance\u2014lld linked executables in about half the time of GNU gold, while maintaining similar output size. The article emphasized that lld was rewritten from scratch as a relatively lean ~7000 lines of C++ code with a cleaner design philosophy. It was designed to be command-line compatible with GNU ld while dropping obsolete features and simplifying implementation. The discussion thread focused on architecture support limitations, licensing (GPL vs permissive), the relationship between lld and gold, and the difference between static linkers and dynamic linkers.",
  "what_happened": "LLD became highly successful and widely adopted. It reached production-quality status for x86-64 ELF platforms and was adopted by major projects including Google (which uses it in production), Apple (adopted Mach-O version for debug builds by 2021-2022, saving 20-50% link time), Chromium, and FreeBSD (as the default linker). The original author, Rui Ueyama, continued improving LLD but eventually created an even faster successor called Mold in 2021, which achieves 5-25x speedups over LLD through aggressive multi-core parallelism. By 2025, Rust 1.90.0 adopted LLD as the default Linux linker. LLD support expanded to multiple architectures including ARM, PowerPC, and s390x. The LLVM permissive (Apache 2.0) licensing proved strategically important, especially for Apple. The comments' concerns about architecture support turned out to be prescient\u2014this became a focus area for LLD development. However, the comments didn't anticipate Mold, which would push linker performance even further.",
  "most_prescient": {
    "user": "mschuster91",
    "reason": "Correctly identified that lld's speed advantage came from supporting fewer architectures/formats compared to GNU gold's broader compatibility. This architectural/market segmentation approach indeed defined lld's strategy for years\u2014focus on x86-64 first, then incrementally add support for other architectures. The prescience was in understanding that narrow scope enables both speed and simplicity."
  },
  "most_wrong": {
    "user": "imglorp",
    "reason": "Warned that the community 'needs to keep the GNU one prospering if we want to avoid proprietary tool hell,' implying LLVM wouldn't be sufficient and that GNU tools must be maintained. While the concern was understandable, this overestimated the staying power of GNU gold and underestimated LLVM's trajectory. In hindsight, LLVM became the dominant free toolchain, especially with Apple's backing, making this concern largely moot. The statement also missed that having multiple competing open toolchains (LLVM vs GNU) was healthier than any single monopoly."
  },
  "notable_aspects": "1) The prescient comment about licensing from msbarnett about Apple's preference for permissive licenses turned out to be crucial\u2014Apple did heavily invest in LLVM's Mach-O support, and the permissive license was genuinely important for corporate adoption. 2) DannyBee's point that lld didn't yet support string section merging (identified as the slowest part of gold) was vindicated as a real performance bottleneck. 3) The discussion of whether to modify gold vs rewrite completely reflected a real engineering trade-off: the GPL v3 licensing made forking and permissive-licensed development more attractive than improving gold incrementally. 4) rui314's humility about not yet conducting serious benchmarking ('measure, don't guess') was notable and professional\u2014the author was properly cautious about performance claims.",
  "grades": {
    "evmar": {
      "grade": "B+",
      "rationale": "Asked the right fundamental question about what made lld faster. While they didn't provide the answer, they identified the core technical mystery that the thread went on to clarify."
    },
    "mschuster91": {
      "grade": "A-",
      "rationale": "Correctly diagnosed that reduced scope (x86-64 only vs broad architecture support) was the key to speed. This architectural insight proved correct for lld's trajectory over the next decade. Minor deduction because they understated MIPS and network processors' importance."
    },
    "ithkuil": {
      "grade": "B",
      "rationale": "Provided good context about gold's design and BFD library concerns. However, they didn't connect this to broader LLVM strategy or consider that multiple linkers could thrive."
    },
    "imglorp": {
      "grade": "D+",
      "rationale": "Made reasonable concerns about portability and proprietary tool risks, but this aged poorly. The warning about needing to 'keep GNU prospering' didn't account for LLVM's strength or the fact that competition between multiple open toolchains was healthy. The statement about Snapdragon/A4 being ARM was the correct technical fact admitted in the thread."
    },
    "DannyBee": {
      "grade": "A",
      "rationale": "Identified that string section merging was a key performance bottleneck in gold and correctly noted lld didn't support it yet. This specific technical insight about gold's Achilles heel proved accurate and important for understanding the performance gap."
    },
    "rui314": {
      "grade": "A+",
      "rationale": "The article author showed professional rigor by acknowledging lack of serious benchmarking, pointing to design documents for technical justification, and being transparent about missing features. Later went on to create Mold, validating their deep understanding of linker performance optimization."
    },
    "jbandela1": {
      "grade": "B",
      "rationale": "Asked practical questions about archive file ordering and circular dependencies. The response confirmed lld solved these issues, showing it had thought through real-world linker problems."
    },
    "jamesdutc": {
      "grade": "C",
      "rationale": "Confused static linkers with dynamic linkers and asked about LD_PRELOAD support in a linker, showing a conceptual gap. However, the educational points about linker features (dlmopen, LD_AUDIT) were valid, just misdirected."
    },
    "msbarnett": {
      "grade": "A",
      "rationale": "Correctly identified that GPL v3 vs permissive licensing was a key strategic factor, especially for Apple. This proved accurate\u2014Apple's investment in LLVM tooling was significantly enabled by permissive licensing."
    },
    "coderdude": {
      "grade": "B",
      "rationale": "Appreciative comment lacking technical depth but showed good perspective on recognizing unnoticed engineering work. Predictions-wise, they were correct that many would not notice this work, but this was fairly obvious."
    }
  },
  "score": 8
}